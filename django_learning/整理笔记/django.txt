在创建的app中的views.py中：
1.首先导入库
form django.shortcuts import render
2.而后定义视图函数，其中，request.GET = {"id" : 3}  GET相当于字典请求，具体看book app的views.py文件
3.定义完视图函数后，去到urls.py文件里实现映射，与django基本操作里加path操作一致，但是前提要在此文件中导入from book import views，以次来识别views文件里的内容。
【注意：在path中填写的视图函数后续要把自带的括号删除，具体可以看文件里的操作】
------------------------------------------------------------------------
关于django里的<book-id>表示形参，与flask里的表达不太相同。如果要在django里定义<xx>,则在views.py文件里定义视图函数里的request后续跟一个要定义的形参，具体操作可以看文件里的形式。
------------------------------------------------------------------------
关于渲染模板：
最简单最快捷的一种方式，直接将模板渲染成字符串和包装成HttpResponse对象一步到位完成，代码示例如下：
from django.shortcuts import render
def book-list(request):
	return render(request,'list.html')
-----------------------------------------------------------------------
setting.py的配置：
1.TEMPLATES：这个配置包含了模板引擎，模板查找路径的配置，模板上下文的配置等，模板路径配置可以在以下两个地方配置：
1）DIRS：一个列表，可以存放所有模板路径，在后续的视图中使用render或render_to_string渲染模板时，会在这个列表的路径中查找模板。
（如果要导入html文件，则把HTML文件在templates文件包里创建【如果是自己创建的templates文件时，需要去setting里在TEMPLATES中的DIRS把路径补全eg.[BASE_DIR(表示项目的根路径) / 'templates']】）
2）APP_DIRS：默认为True，设置为true后，会在INSTALLED_APP中安装app下的templates文件夹中查找模板。
（如果在app文件创建的templates文件，并在里面创建了HTML文件，则需要在setting.py里的INSTALLED_APPS里添加app的名字进行加载导入（eg.以templatesdemo项目里的baidu为例）
【前提：setting中的templates里的APP_OIRS跟着的是Ture】）
2.查找顺序：先在DIRS这个列表里依次查找路径下是否有此模板，如果有，就放回；如果在此所有的路径都没有找到，则先检查当前视图所处app是否已经安装在INSTALLED_APPS中，如果已经安装，先在当前app下的templates文件夹中查找模板，如果没有找到，则取其他已经安装的app中查找。如果所有路径下都没有查找到，那么会抛出一个TemplateDoesNotExist异常。
--------------------------------------------------------------------
视图函数传参：
1.普通传参：先定义一个变量名xx，后续在render里添加一个context={"xx":xx}，在html文件里添加像jinja2类似的{{ xx }}进行传参。
2.字典类型传参：定义一个变量名book，写成字典类型，后续操作一样{{ book.key }}。
3.列表传参：定义一个列表【如果参数过多，可以将context单独领出来】,后续操作一样{{ books.1.key }}，多了一个要选择下标数
4.对象传参：
class Person:
	def __init__(self,realname):
		self.realname = realname
在后续的context中，{"person":Person("realname")}，里面的realname自己填写内容，在html文件中添加{{ person.realname }}则可以实现对象传参。
--------------------------------------------------------------------
模板标签（写法）：
1.if语句：
{% if "xx" in person %}
	<p>xx</p>
{% else %}
	<p>xxx</p>
{% endif %}
2.for语句：
{% for person in persons （reversed）%}
	<p>{{ person.name }}</p>
{% endfor %}
!如果想要反向遍历，那么在遍历时加上reversed
3.遍历字典时：
{% for key,value in person.tiems %}
	<p>key:{{ key }}</p>
	<p>value:{{ value }}</p>
{% endfor %}
4.for循环的变量：
forloop.counter：当前循环的下标，以1作为起始点
forloop.counter0：当前循环的下标以0作为起始点
forloop.revcounter：当前循环的反向下标值，从最后一个元素开始遍历
forloop.revcounter0：与上一个相似，不同的是从最后一个元素的下标是从0开始
forloop.first：是否是第一次遍历
forloop.last：是否是最后一次遍历
forloop.parentloop：如果是多重循环嵌套，那么这个属性代表是上一级的for循环

5.for...in...empty与for语句一样，只不过在遍历时对象可能存在没有元素的情况：
{% for person in persons %}
	<li>{{ person.name }}</li>
{% empty %}
	暂时没有任何人
{% endfor %}
6.with标签：【在变量访问比较复杂的情况，可以先将复杂的变量缓存到一个变量上，而后直接使用】
context = {
	"persons" : ["张三","李四"】
}
{% with list = person.1 %}
	<p>{{ list }}</p>
{% endwith %} 				输出->李四
///
{% with persons.1 as list %}
	<p>{{ list }}</p>
{% endwith %}
7.url标签：【建议使用反转的方式来实现】
<a href="{% url 'book:list'  %}">图书列表页面</a>
1)如果需要传递参数，可以在后面传递，但是！！参数分位置参数和关键字参数，位置参数和关键字参数不能同时使用。eg.
#path部分
path('detail/<book_id>/',views.book_detail,name='detail')
#url反转
<a href="{% url 'book:list' 1 %}">图书详情页面</a>
#url反转，使用关键字参数
<a href="{% url 'book:detail' book_id=1 %}">图书详情页面</a>
2)如果使用url标签反转时需要传递查询字符串的参数，则与flask相同，手动在后面添加即可
<a href="{% url 'book:detail' book_id=1 %}?page=1">图书详情页面</a>
3)如果需要传递多个参数，则用空格的方式进行分隔
<a href="{% url 'book:detail' book_id=1 page=2 %}">图书详情页面</a>
8.spaceless标签：【移除html文件中的空白字符】
{% spaceless %}
	<p>
		<a href='foo/'>Foo<a/>
	</p>
{% endspaceless %}  			渲染后代码-><p><a href='foo/'>Foo</a></p>


------------------------------
